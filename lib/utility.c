/* This file is part of the SDTGEN Project - an LR(1) scanner and parser      */
/* generator and associated tools providing automatic locally least-cost      */
/* error repair.							      */
/* Copyright (C) 2024  Roy J. Mongiovi					      */
/*									      */
/* SDTGEN is free software: you can redistribute it and/or modify it	      */
/* under the terms of the GNU Lesser General Public License as published      */
/* by the Free Software Foundation, either version 3 of the License, or	      */
/* (at your option) any later version.					      */
/*									      */
/* This program is distributed in the hope that it will be useful, but	      */
/* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY */
/* or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License   */
/* for more details.							      */
/*									      */
/* You should have received a copy of the GNU General Public License along    */
/* with this program.  If not, see <https://www.gnu.org/licenses/>.	      */

#include <ctype.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

#include "parser_definitions.h"
#include "utility_definitions.h"


int char_width
(
   int ch,
   int type,
   int col
)
{
/* Return the length of characters generated by display_char */

	if (ch == ENDFILE)
      return(3);
   else if (ch == '\\')
      if (type != RAW_CHAR)
	 return(2);
      else
	 return(1);
   else if (ch == '\t')
      if (type != RAW_CHAR)
	 return(2);
      else
	 return(8 - (col & 7));
   else if (ch == '\a' || ch == '\b' || ch == '\e' || ch == '\f' || ch == '\n' || ch == '\r' || ch == '\v')
      return(2);
   else if (type == CLASS_CHAR && ch == ']')
      return(2);
   else if (isprint(ch))
      return(1);
   else
      return(4);
}


void display_char
(
   int	 ch,
   int	 type,
   FILE *fp
)
{
/* Display character in standard printable format */

	if (ch == ENDFILE)
      fputs("EOF", fp);
   else if (ch == '\\')
      if (type != RAW_CHAR)
	 fputs("\\\\", fp);
      else
         fputs("\\", fp);
   else if (ch == '\t')
      if (type != RAW_CHAR)
	 fputs("\\t", fp);
      else
	 fputc('\t', fp);
   else if (ch == '\a')
      fputs("\\a", fp);
   else if (ch == '\b')
      fputs("\\b", fp);
   else if (ch == '\e')
      fputs("\\e", fp);
   else if (ch == '\f')
      fputs("\\f", fp);
   else if (ch == '\n')
      fputs("\\n", fp);
   else if (ch == '\r')
      fputs("\\r", fp);
   else if (ch == '\v')
      fputs("\\v", fp);
   else if (type == CLASS_CHAR && ch == ']')
      fputs("\\]", fp);
   else if (isprint(ch))
      fputc(ch, fp);
   else
      fprintf(fp, "\\x%.2X", ch);
}


int hash_string
(
   unsigned char *string
)
{
/* The Fowler/Noll/Vo hash function 1A */

   uint32_t value;			/* Accumulated integer value of symbol */

   for (value = 0x811c9dc5L; *string; string++)
   {
      value ^= *string;
/*    value *= 0x01000193L; */
      value += (value << 1) + (value << 4) + (value << 7) + (value << 8) + (value << 24);
   }
   return(value % HASH_TABLE_SIZE);	/* Reduce to range 0..HASH_TABLE_SIZE-1 */
}


void out_of_memory
(
   void
)
{
/* Report memory error and exit the program */

   fputs("insufficient memory\n", stderr);
   exit(1);
}
