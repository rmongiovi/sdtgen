/* This file is part of the SDTGEN Project - an LR(1) scanner and parser      */
/* generator and associated tools providing automatic locally least-cost      */
/* error repair.							      */
/* Copyright (C) 2024  Roy J. Mongiovi					      */
/*									      */
/* SDTGEN is free software: you can redistribute it and/or modify it	      */
/* under the terms of the GNU Lesser General Public License as published      */
/* by the Free Software Foundation, either version 3 of the License, or	      */
/* (at your option) any later version.					      */
/*									      */
/* This program is distributed in the hope that it will be useful, but	      */
/* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY */
/* or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License   */
/* for more details.							      */
/*									      */
/* You should have received a copy of the GNU General Public License along    */
/* with this program.  If not, see <https://www.gnu.org/licenses/>.	      */

#include <ctype.h>
#include <limits.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "intset_definitions.h"
#include "partree_definitions.h"
#include "scangen_definitions.h"
#include "sdtgen_definitions.h"
#include "symbols_definitions.h"
#include "tables_definitions.h"
#include "utility_definitions.h"

#include "dynarray_functions.h"
#include "intset_functions.h"
#include "partree_functions.h"
#include "utility_functions.h"


static int  bitmap_size(unsigned char [MAPSIZE]);
static void build_dfa(sdt_tables *, intset *);
static void build_nfa(sdt_tables *, treenode *, bool, bool *, intset *, intset *);
static void cleanup_tokens(sdt_tables *);
static bool compatible(sdt_tables *, dfastate *, dfastate *);
static int  count_positions(treenode *);
static bool create_bitmap(treenode *, bool, unsigned char *);
static void display_bitmap(unsigned char [MAPSIZE], FILE *);
static void display_dfa(sdt_tables *, char *, FILE *);
static void display_nfa(sdt_tables *, intset *, FILE *);
static void display_terminals(sdt_tables *, FILE *);
static bool expand_class(unsigned char *, unsigned char *);
static void free_automaton(sdt_tables *);
static void free_positions(sdt_tables *);
static void list_tokens(sdt_tables *, treenode *, int, int, bool, FILE *);
static void list_values(sdt_tables *, symbolentry *, int, int, treenode *, int, FILE *);
static int  lookup_state(sdt_tables *, intset *);
static void minimize_dfa(sdt_tables *);


static int bitmap_size
(
   unsigned char bitmap[MAPSIZE]
)
{
/* Calculates the size of the string generated by display_bitmap */

   int	size;
   bool flag;
   int	first;
   int	last;
   int	i;

   size = 1;
   if (flag = BITTST(bitmap, '-'))
   {
      BITCLR(bitmap, '-');
      size++;
   }
   for (first = -1, i = 0; i <= ENDFILE; i++)
      if (BITTST(bitmap, i))
      {
         if (first == -1)
	    first = i;
	 last  = i;
      }
      else
         if (first >= 0)
	 {
	    size += char_width(first, CLASS_CHAR, 0);
	    if (first < last)
	       size += char_width(last, CLASS_CHAR, 0) + 1;
	    first = -1;
	 }
   if (first >= 0)
   {
      size += char_width(first, CLASS_CHAR, 0);
      if (first < last)
         size += char_width(last, CLASS_CHAR, 0) + 1;
      first = -1;
   }
   if (flag)
      BITSET(bitmap, '-');
   return(size + 1);
}


static void build_dfa
(
   sdt_tables *tables,
   intset     *first
)
{
   int	      count;
   int	      input;
   intset     merge;
   transition action[MAPCOUNT];
   int	      i, j, k;

   if (INTCOUNT(*first))
   {
      for (i = lookup_state(tables, first); i < DFACOUNT; i++)
      {
	 for (count = 0, input = 0; input <= ENDFILE; input++)
	 {
/*	    Union all the states that this state transitions to on input character */

	    for (INTCOUNT(*first) = 0, j = 0; j < INTCOUNT(DFASTATE(i).states); j++)
	    {
	       k = INTSET(DFASTATE(i).states, j);

	       if (BITTST(NFAPOSITION(k).bitmap, input))
	       {
		  intset_union(&merge, first, &NFAPOSITION(k).follow);
		  intset_free(first);
		  *first = merge;
	       }
	    }

/*	    If we have a transition on input append it to this state's actions */

	    if (INTCOUNT(*first))
	    {
	       action[count  ].index = input;
	       action[count++].state = lookup_state(tables, first);
	    }
	 }

/*	 If we have created an action list copy it into the state */

	 if (count)
	 {
	    if (!(DFASTATE(i).action = (transition *) malloc(count * sizeof(*action))))
	       out_of_memory();
	    memcpy(DFASTATE(i).action, action, (DFASTATE(i).count = count) * sizeof(*action));
	 }
      }
      cleanup_tokens(tables);

/*    We're finished with the NFA so free it */

      free_positions(tables);

/*    Display the DFA before minimization if requested */

      if (tables->debug & DEBUG_D)
	 display_dfa(tables, "Before", stdout);

/*    Now minimize the number of states in the DFA */

      minimize_dfa(tables);

/*    Display the DFA after minimization if requested */

      if (tables->debug & DEBUG_M)
	 display_dfa(tables, "After", stdout);
   }
   else
   {
      free_positions(tables);

      tables->termcount = 0;
      tables->dfacount  = 0;
   }
}


static void build_nfa
(
   sdt_tables *tables,
   treenode   *tree,
   bool	       bothcase,
   bool	      *nullable,
   intset     *firstpos,
   intset     *lastpos
)
{
/* Convert the scanner abstract syntax tree into a nondeterministic finite state automaton */

   intset    first;
   intset    last;
   intset    token;
   treenode *node;
   int	     start;
   bool	     both;
   bool	     null;
   intset    merge;
   int	     length;
   char	     c;
   int	     i, j;

   intset_alloc(&first, INITIAL_NFASET_SIZE);
   intset_alloc(&last, INITIAL_NFASET_SIZE);
   intset_alloc(&token, 1);

   if (tree->node.count != LEAF)
      switch (tree->node.type)
      {
	 case '.':

/*	    Check the last node in the concatenation for a token definition */
/*	    and if it was found check if it specifies case insignificance   */

	    node = tree->node.entry[3];
	    both = node->node.count == LEAF && node->leaf.type == REFERENCE && (node->leaf.value.symbol->value.value.flags & CASE);

/*	    Remember the size of the NFA before building this token */

	    start = NFACOUNT;

/*	    Build the positions for the leftmost regular expression of the concatenation */

	    build_nfa(tables, node = tree->node.entry[0], both, nullable, firstpos, lastpos);

/*	    Process the remaining nodes in the concatenation */

	    while (node = node->node.next)
	       if (node->node.count != LEAF || node->leaf.type != LOOKAHEAD && node->leaf.type != REFERENCE)
	       {
/*		  Append next regular expression in the concatenation */

		  build_nfa(tables, node, both, &null, &first, &last);

/*		  If we have last positions for the previous regular expression */
/*		  and first positions for the current regular expression update	*/
/*		  follow sets to connect the concatenated regular expressions	*/

		  if (INTCOUNT(*lastpos) && INTCOUNT(first))
		     for (i = 0; i < INTCOUNT(*lastpos); i++)
		     {
			intset_union(&merge, &NFAPOSITION(INTSET(*lastpos, i)).follow, &first);
			intset_free(&NFAPOSITION(INTSET(*lastpos, i)).follow);
			NFAPOSITION(INTSET(*lastpos, i)).follow = merge;
		     }

/*		  If the previous regular expressions are nullable add the first positions of the current */
/*		  regular expression to the first positions of the concatenated regular expressions	  */

		  if (*nullable)
		  {
		     intset_union(&merge, firstpos, &first);
		     intset_free(firstpos);
		     *firstpos = merge;
		  }
		  INTCOUNT(first) = 0;

/*		  If the current regular expression is nullable then add its last positions to the */
/*		  last positions of the concatenated regular expression otherwise replace the last */
/*		  positions of the concatenated regular expression with those of the current	   */

		  if (null)
		  {
		     intset_union(&merge, lastpos, &last);
		     intset_free(lastpos);
		     *lastpos = merge;
		     INTCOUNT(last) = 0;
		  }
		  else
		  {
		     intset_free(lastpos);
		     *lastpos = last;
		     intset_alloc(&last, INITIAL_NFASET_SIZE);
		  }

/*		  If the previous and current regular expressions are nullable */
/*		  then so is the concatenated regular expression	       */

		  *nullable = *nullable && null;
	       }
	       else
		  if (node->leaf.type == LOOKAHEAD)
		  {
/*		    Save the last positions of the current regular expression */

		     intset_free(&token);
		     intset_copy(&token, lastpos);
		  }
		  else
		     if (NFACOUNT > start)
		     {
/*			Create token final state if we added states for a regular expression */

			intset_alloc(&NFAPOSITION(NFACOUNT).follow, INITIAL_NFASET_SIZE);

/*			Connect all the last positions to the final state */

			for (i = 0; i < INTCOUNT(*lastpos); i++)
			   intset_insert(&NFAPOSITION(INTSET(*lastpos, i)).follow, NFACOUNT);

			if (INTCOUNT(token))

/*			   If a lookahead was specified put this token value in all the lookahead positions */

			   for (i = 0; i < INTCOUNT(token); i++)
			      for (j = 0; j < INTCOUNT(NFAPOSITION(INTSET(token, i)).follow); j++)
				 NFAPOSITION(INTSET(NFAPOSITION(INTSET(token, i)).follow, j)).token = node->leaf.value.symbol->value.value.token;
			else

/*			   Put this token value in the new final state */

			   NFAPOSITION(NFACOUNT).token = node->leaf.value.symbol->value.value.token;

/*			Set the final state token value */

			NFAPOSITION(NFACOUNT).final = node->leaf.value.symbol->value.value.token;
			NFAPOSITION(NFACOUNT).install = node->leaf.value.symbol->value.value.flags & INSTALL;
			NFACOUNT++;
		     }
	    break;

	 case '|':

/*	    Create all alternative regular expression and union first and last positions */

	    build_nfa(tables, node = tree->node.entry[0], bothcase, nullable, firstpos, lastpos);
	    while (node = node->node.next)
	    {
	       build_nfa(tables, node, bothcase, &null, &first, &last);
	       intset_union(&merge, firstpos, &first);
	       intset_free(firstpos);
	       *firstpos = merge;
	       INTCOUNT(first) = 0;
	       intset_union(&merge, lastpos, &last);
	       intset_free(lastpos);
	       *lastpos = merge;
	       INTCOUNT(last) = 0;
	       *nullable = *nullable || null;
	    }
	    break;

	 case '*':
	 case '+':

/*	    Create repeated regular expression */

	    build_nfa(tables, tree->node.entry[0], bothcase, nullable, firstpos, lastpos);

/*	    Make all the first positions follow all the last positions */

	    for (i = 0; i < INTCOUNT(*lastpos); i++)
	    {
	       intset_union(&merge, &NFAPOSITION(INTSET(*lastpos, i)).follow, firstpos);
	       intset_free(&NFAPOSITION(INTSET(*lastpos, i)).follow);
	       NFAPOSITION(INTSET(*lastpos, i)).follow = merge;
	    }

/*	    If the regular expression is nullable or this is 0 or more reps then it's nullable */

	    *nullable = *nullable || tree->node.type == '*';
	    break;

	 case '-':
	 case '~':
	 case ':':
	    if (!create_bitmap(tree, bothcase, NFAPOSITION(NFACOUNT).bitmap))
	    {
/*	       Add a position for the single constructed transition */

	       intset_alloc(&NFAPOSITION(NFACOUNT).follow, INITIAL_NFASET_SIZE);

	       intset_insert(firstpos, NFACOUNT);
	       intset_insert(lastpos, NFACOUNT);
	       *nullable = false;
	       NFACOUNT++;
	    }
	    else

/*	       Since the transition is empty all we have to know is that it is nullable */

	       *nullable = true;
	    break;

	 default:
	    puts("Internal error - unknown node detected in build_nfa");
	    exit(1);
      }
   else
      switch (tree->leaf.type)
      {
	 case CHARACTER:

/*	    Create a bitmap for each character in the string */

	    intset_insert(firstpos, NFACOUNT);
	    for (length = strlen(tree->leaf.value.value), i = 0; i < length; i++)
	    {
/*	       Create transitions for both cases of character if necessary */

	       c = tree->leaf.value.value[i];
	       BITSET(NFAPOSITION(NFACOUNT).bitmap, c);
	       if (bothcase)
		  if (isupper(c))
		     BITSET(NFAPOSITION(NFACOUNT).bitmap, tolower(c));
		  else
		     if (islower(c))
			BITSET(NFAPOSITION(NFACOUNT).bitmap, toupper(c));

/*	       If there is a next character connect it to the current character */

	       intset_alloc(&NFAPOSITION(NFACOUNT).follow, INITIAL_NFASET_SIZE);
	       if (i < length - 1)
		  intset_insert(&NFAPOSITION(NFACOUNT).follow, NFACOUNT + 1);
	       NFACOUNT++;
	    }
	    intset_insert(lastpos, NFACOUNT - 1);
	    *nullable = false;
	    break;

	 case CLASS:
	 case ZEROBYTE:
	 case ENDOFFILE:

/*	    Create a bitmap for a single character class or byte */

	    intset_insert(firstpos, NFACOUNT);
	    intset_insert(lastpos, NFACOUNT);
	    *nullable = create_bitmap(tree, bothcase, NFAPOSITION(NFACOUNT).bitmap);
	    intset_alloc(&NFAPOSITION(NFACOUNT).follow, INITIAL_NFASET_SIZE);
	    NFACOUNT++;
	    break;

	 case EPSILON:
	    *nullable = true;
	    break;

	 default:
	    puts("Internal error - unknown node detected in build_nfa");
	    exit(1);
      }
   intset_free(&first);
   intset_free(&last);
   intset_free(&token);
}


static void cleanup_tokens
(
   sdt_tables *tables
)
{
   intset final;
   intset intersect;
   int	  i;

/* Create a set of all the tokens that made it to final states */

   intset_alloc(&final, INITIAL_TOKENS_SIZE);
   for (i = 1; i < DFACOUNT; i++)
      if (DFASTATE(i).final)
	 intset_insert(&final, DFASTATE(i).final);

/* Remove any values that didn't make it from end of token values */

   for (i = 1; i < DFACOUNT; i++)
   {
      intset_intersect(&intersect, &DFASTATE(i).tokens, &final);
      intset_free(&DFASTATE(i).tokens);
      DFASTATE(i).tokens = intersect;
   }
   intset_free(&final);
}


static bool compatible
(
   sdt_tables *tables,
   dfastate   *state1,
   dfastate   *state2
)
{
   int i;

/* Compatible states must have the same transitions to the same groups */

   if (state1->count == state2->count)
   {
      for (i = 0; i < state1->count; i++)
	 if (state1->action[i].index != state2->action[i].index || DFASTATE(state1->action[i].state).index != DFASTATE(state2->action[i].state).index)
	    return(false);
      return(true);
   }
   else
      return(false);
}


static int count_positions
(
   treenode *tree
)
{
/* Calculate how many NFA positions have to be allocated */

   long      count;
   treenode *node;

   if (tree->node.count != LEAF)
      switch (tree->node.type)
      {
	 case '.':
	 case '|':
	    for (count = 0, node = tree->node.entry[0]; node; node = node->node.next)
	       count += count_positions(node);
	 break;

	 case '*':
	 case '+':
	    count = count_positions(tree->node.entry[0]);
	    break;

	 case '-':
	 case '~':
	 case ':':
	    count = 1;
      }
   else
      switch (tree->leaf.type)
      {
	 case EPSILON:
	 case LOOKAHEAD:
	    count = 0;
	    break;

	 case REFERENCE:
	 case CLASS:
	 case ZEROBYTE:
	 case ENDOFFILE:
	    count = 1;
	    break;

	 case CHARACTER:
	    count = strlen(tree->leaf.value.value);
      }
   return((count <= INT_MAX) ? (int) count : INT_MAX);
}


static bool create_bitmap
(
   treenode	*tree,
   bool		 bothcase,
   unsigned char bitmap[MAPSIZE]
)
{
   unsigned char value1[MAPSIZE];
   unsigned char value2[MAPSIZE];
   treenode	*node;
   bool		 empty;
   int		 i, j;

   if (tree->node.count != LEAF)
      switch (tree->node.type)
      {
	 case '.':	/* Concatenation */

/*	 Since create_bitmap only works on a single character or class	   */
/*	 if this is a concatenation it must be one node containing a	   */
/*	 single character or a class concatenated with one or more epsilon */
/*	 strings.  So we just loop through the concatenation until we find */
/*	 a non-epsilon entry and return it. Otherwise we return epsilon	   */

	    for (node = tree->node.entry[0]; node; node = node->node.next)
	       if (!create_bitmap(node, bothcase, bitmap))
		  return(false);
	    memset(bitmap, 0, MAPSIZE);
	    return(true);

	 case '|':      /* Alternation */

/*	    Convert each alternate to a bitmal and or them together */

	    memset(bitmap, 0, MAPSIZE);
	    empty = true;
	    for (node = tree->node.entry[0]; node; node = node->node.next)
	       if (!create_bitmap(node, bothcase, value1))
	       {
		  for (i = 0; i < MAPSIZE; i++)
		     bitmap[i] |= value1[i];
		  empty = false;
	       }
	    return(empty);

	 case '-':      /* Character difference */

/*	    Convert each side of the difference to a  */
/*	    bitmap and remove the right from the left */

	    create_bitmap(tree->node.entry[0], bothcase, value1);
	    create_bitmap(tree->node.entry[1], bothcase, value2);
	    for (i = 0; i < MAPSIZE; i++)
	       bitmap[i] = ~value2[i] & value1[i];
	    for (i = 0; i < MAPSIZE; i++)
	       if (bitmap[i])
		  return(false);
	    return(true);

	 case '~':      /* Character complement */

/*	    Convert the character or class to a bitmap and complement it */

	    create_bitmap(tree->node.entry[0], bothcase, bitmap);
	    for (i = 0; i < MAPSIZE; i++)
	       bitmap[i] ^= 0xFF;
	    BITCLR(bitmap, ENDFILE);
	    for (i = 0; i < MAPSIZE; i++)
	       if (bitmap[i])
		  return(false);
	    return(true);

	 case ':':      /* Range of characters */

/*	    Add each character in a range to a bitmap */

	    memset(bitmap, 0, MAPSIZE);
	    i = *tree->node.entry[0]->leaf.value.value;
	    j = *tree->node.entry[1]->leaf.value.value;
	    empty = i > j;
	    while (i <= j)
	    {
	       BITSET(bitmap, i);
	       if (bothcase)
	          if (islower(i))
		     BITSET(bitmap, toupper(i));
		  else
		     if (isupper(i))
			BITSET(bitmap, tolower(i));
	       i++;
	    }
	    return(empty);

	 default:
	    memset(bitmap, 0, MAPSIZE);
	    return(true);
      }
   else
      switch (tree->leaf.type)
      {
	 case CHARACTER:

/*	    Create a bitmap containing a single character */

	    memset(bitmap, 0, MAPSIZE);
	    BITSET(bitmap, *tree->leaf.value.value);
	    return(false);

	 case CLASS:

/*	    Convert a character class into a bitmap */

	    return(expand_class(bitmap, tree->leaf.value.value));

	 case ZEROBYTE:

/*	    Create a bitmap for character \x00 */

	    memset(bitmap, 0, MAPSIZE);
	    BITSET(bitmap, 0);
	    return(false);

	 case ENDOFFILE:

/*	    Create a bitmap for end of file */

	    memset(bitmap, 0, MAPSIZE);
	    BITSET(bitmap, ENDFILE);
	    return(false);

	 case EPSILON:
         default:

/*	    Create an empty bitmap */

	    memset(bitmap, 0, MAPSIZE);
	    return(true);
      }
}


static void display_bitmap
(
   unsigned char bitmap[MAPSIZE],
   FILE		*fp
)
{
/* Display characters matched by bitmap */

   bool flag;
   int	first;
   int	last;
   int	i;

   fputc('[', fp);
   if (flag = BITTST(bitmap, '-'))
   {
      fputc('-', fp);
      BITCLR(bitmap, '-');
   }
   for (first = -1, i = 0; i <= ENDFILE; i++)
      if (BITTST(bitmap, i))
      {
         if (first == -1)
	    first = i;
	 last  = i;
      }
      else
         if (first >= 0)
	 {
	    display_char(first, CLASS_CHAR, fp);
	    if (first < last)
	    {
	       fputc('-', fp);
	       display_char(last, CLASS_CHAR, fp);
	    }
	    first = -1;
	 }
   if (first >= 0)
   {
      display_char(first, CLASS_CHAR, fp);
      if (first < last)
      {
	 fputc('-', fp);
	 display_char(last, CLASS_CHAR, fp);
      }
      first = -1;
   }
   if (flag)
      BITSET(bitmap, '-');
   fputc(']', fp);
}


static void display_dfa
(
   sdt_tables *tables,
   char	      *title,
   FILE	      *fp
)
{
/* Display active states in the deterministic finite state automaton */

   int width1;
   int width2;
   int width3;
   int size;
   int first;
   int last;
   int i, j;

/* Determine the maximum size of various fields so they can be lined up */

   for (width1 = 0, i = 1; i < DFACOUNT; i++)
      if (DFASTATE(i).index > width1)
	 width1 = DFASTATE(i).index;
   width1 = digit_count(width1);
   if (width1 < 5)
      width1 = 5;
   for (width3 = width2 = 0, i = 1; i < DFACOUNT; i++)
   {
      if ((size = intset_size(&DFASTATE(i).tokens)) > width2)
	 width2 = size;
      if ((size = digit_count(DFASTATE(i).final)) > width3)
	 width3 = size;
   }
   if (width2 < 6)
      width2 = 6;
   if (width3 < 5)
      width3 = 5;

   fprintf(fp, "%s\t%s\tScanner Deterministic Automaton %s Minimization\n", tables->name, tables->title, title);
   fprintf(fp, "%*s: %-*s %-*s Transitions\n", width1, "State", width2 + 2, "Tokens", width3, "Final");
   for (i = 1; i < DFACOUNT; i++)
      if (DFASTATE(i).index)
      {
	 fprintf(fp, "%*d: [", width1, DFASTATE(i).index);
	 display_intset(&DFASTATE(i).tokens, fp);
	 fputc(']', fp);
	 if ((size = intset_size(&DFASTATE(i).tokens)) < width2)
	    fprintf(fp, "%*s", width2 - size, " ");
	 fprintf(fp, " %*d [", width3, DFASTATE(i).final);
	 if (DFASTATE(i).count)
	 {
	    for (first = last = 0, j = 1; j < DFASTATE(i).count; j++)
	    {
	       if (DFASTATE(i).action[j].index != DFASTATE(i).action[last].index + 1 || DFASTATE(i).action[j].state != DFASTATE(i).action[last].state)
	       {
		  display_char(DFASTATE(i).action[first].index, CLASS_CHAR, fp);
		  if (first < last)
		  {
		     fputc('-', fp);
		     display_char(DFASTATE(i).action[last].index, CLASS_CHAR, fp);
		  }
		  fprintf(fp, "=%d", DFASTATE(DFASTATE(i).action[last].state).index);
		  if (j < DFASTATE(i).count)
		     fputc(' ', fp);
		  first = j;
	       }
	       last = j;
	    }
	    display_char(DFASTATE(i).action[first].index, CLASS_CHAR, fp);
	    if (first < last)
	    {
	       fputc('-', fp);
	       display_char(DFASTATE(i).action[last].index, CLASS_CHAR, fp);
	    }
	    fprintf(fp, "=%d", DFASTATE(DFASTATE(i).action[last].state).index);
	    if (j < DFASTATE(i).count - 1)
	       fputc(' ', fp);
	 }
	 fputs("]\n", fp);
      }
   fputc('\n', fp);
}


static void display_nfa
(
   sdt_tables *tables,
   intset     *first,
   FILE	      *fp
)
{
/* Display the nondeterministic finite state automaton */

   int width1;
   int width2;
   int width3;
   int width4;
   int size;
   int i;

/* Determine the maximum size of various fields so they can be lined up */

   width1 = digit_count(NFACOUNT);
   if (width1 < 5)
      width1 = 5;
   for (width4 = width3 = width2 = 0, i = 1; i < NFACOUNT; i++)
   {
      if (NFAPOSITION(i).token > width2)
	 width2 = NFAPOSITION(i).token;
      if (NFAPOSITION(i).final > width3)
         width3 = NFAPOSITION(i).final;
      if ((size = bitmap_size(NFAPOSITION(i).bitmap)) > width4)
         width4 = size;
   }
   width2 = digit_count(width2);
   if (width2 < 5)
      width2 = 5;
   width3 = digit_count(width3);
   if (width3 < 5)
      width3 = 5;
   if (width4 < 5)
      width4 = 5;

   fprintf(fp, "%s\t%s\tScanner Nondeterministic Automaton\n", tables->name, tables->title);
   fprintf(fp, "%*s: [", width1, "Start");
   display_intset(first, fp);
   fputs("]\n", fp);
   fprintf(fp, "%*s: %-*s %-*s %-*s Next States\n", width1, "State", width2, "Token", width3, "Final", width4, "Chars");
   for (i = 1; i < NFACOUNT; i++)
   {
      fprintf(fp, "%*d: %*d %*d ", width1, i, width2, NFAPOSITION(i).token, width3, NFAPOSITION(i).final);
      display_bitmap(NFAPOSITION(i).bitmap, fp);
      if ((size = bitmap_size(NFAPOSITION(i).bitmap)) < width4)
         fprintf(fp, "%*s", width4 - size, " ");
      fputs(" [", fp);
      display_intset(&NFAPOSITION(i).follow, fp);
      fputs("]\n", fp);
   }
   fputc('\n', fp);
}


static void display_terminals
(
   sdt_tables *tables,
   FILE	      *fp
)
{
/* Display the scanner abstract syntax tree as readable tokens */

   int	     width1;
   int	     width2;
   treenode *tree;
   treenode *node;
   int	     length;

/* Determine the width of the various fields */

   width1 = digit_count(tables->tokenval.token);
   if (width1 < 3)
      width1 = 3;
   if (tables->scanner->node.count != LEAF && tables->scanner->node.type == '|')
   {
/*    Scan the list of alternative token definitions */

      for (width2 = 0, tree = tables->scanner->node.entry[0]; tree; tree = tree->node.next)
      {
	 node = tree->node.entry[3];
	 if (node->node.count == LEAF && node->leaf.type == REFERENCE && node->leaf.value.symbol->type == TERMINAL)
	    if ((length = strlen(node->leaf.value.symbol->symbol)) > width2)
	       width2 = length;
      }
   }
   else
   {
/*    There is only one token defined */

      node = tables->scanner->node.entry[3];
      if (node->node.count == LEAF && node->leaf.type == REFERENCE && node->leaf.value.symbol->type == TERMINAL)
	 width2 = strlen(node->leaf.value.symbol->symbol);
      else
	 width2 = 0;
   }
   if (width2 < 5)
      width2 = 5;

   fprintf(fp, "%s\t%s\tRegular Expressions\n", tables->name, tables->title);
   fprintf(fp, "%*s.  %-*s  Definition\n", width1, "Num", width2 + 3, "Token");
   list_tokens(tables, tables->scanner, width1, width2, false, fp);
   list_tokens(tables, tables->scanner, width1, width2, true, fp);
   fputc('\n', fp);
}


static bool expand_class
(
   unsigned char *bitmap,
   unsigned char *class
)
{
   unsigned char *p;
   bool		  invert;
   int		  c;
   bool		  dup;
   int		  i;

   memset(bitmap, 0, MAPSIZE);
   p = class;

/* Check for negated class */

   if (*p == '^')
   {
      invert = true;
      p++;
   }
   else
      invert = false;

/* Process the remaining characters in the class */

   c   = -1;
   dup = false;
   while (*p)
   {
/*    Check for a range of characters */

      if (*p == '-')

/*	 If there are both a previous and next character this is a range */

	 if (c >= 0 && *(p + 1))
	 {
	    if (c <= *(p + 1))

/*	       The range is non-empty so fill it in */

	       for (i = c + 1; i <= *(p + 1); i++)
		  BITSET(bitmap, i);
	    else

/*	       The range is empty so remove the value we erroneously added */

	       if (!dup)
		  BITCLR(bitmap, c);
	    c   = -1;
	    dup = false;
	    p++;
	 }
	 else
	 {
/*	    This is just a dash */

	    dup = BITTST(bitmap, *p) != 0;
	    BITSET(bitmap, *p);
	    c = *p;
	 }
      else
      {
/*	 Add normal character to class */

	 dup = BITTST(bitmap, *p) != 0;
	 BITSET(bitmap, *p);
	 c = *p;
      }
      p++;
   }

/* If class is inverted invert all the bytes in the bitmap */

   if (invert)
   {
      for (i = 0; i < MAPSIZE; i++)
	 bitmap[i] = ~bitmap[i];
      BITCLR(bitmap, ENDFILE);
   }

/* Determine if class matches no characters */

   for (i = 0; i < MAPSIZE; i++)
      if (bitmap[i])
	 return(false);
   return(true);
}


static void free_automaton
(
   sdt_tables *tables
)
{
/* Free the deterministic finite state automaton */

   int i;

   for (i = 1; i < DFACOUNT; i++)
   {
      if (DFASTATE(i).index)
	 intset_free(&DFASTATE(i).tokens);
      if (DFASTATE(i).count)
	 free(DFASTATE(i).action);
   }
   DFACOUNT = 0;

   dynfree(&tables->dfastates);
   tables->dfacount = 0;
}


static void free_positions
(
   sdt_tables *tables
)
{
/* Free the nondeterministic finite state automaton */

   int i;

/* Free all the NFA positions */

   for (i = 1; i < NFASIZE; i++)
      intset_free(&NFAPOSITION(i).follow);
   dynfree(&tables->nfapositions);

/* And since the NFA is gone free the references to its states */

   for (i = 1; i < DFACOUNT; i++)
      intset_free(&DFASTATE(i).states);
}


void free_scangen
(
   sdt_tables *tables
)
{
/* Free NFA and DFA if normal processing didn't do it */

   free_positions(tables);
   free_automaton(tables);
}


void generate_scanner
(
   sdt_tables *tables
)
{
   intset     firstpos;
   intset     lastpos;
   bool	      nullable;

/* Display abstract syntax tree as tree and as tokens if desired */

   if (tables->debug & DEBUG_S)
      display_syntax(tables, tables->scanner, "Scanner Syntax Tree", stdout);
   if (tables->display & DISPLAY_R)
      display_terminals(tables, stdout);

/* Build positions corresponding to the important states of the NFA */

   intset_alloc(&firstpos, INITIAL_NFASET_SIZE);
   intset_alloc(&lastpos, INITIAL_NFASET_SIZE);
   build_nfa(tables, tables->scanner, false, &nullable, &firstpos, &lastpos);
   intset_free(&lastpos);

/* We've created the NFA from the syntax tree so free the tree */

   free_tree(tables->scanner);
   tables->scanner = NULL;

/* Display the NFA if requested */

   if (tables->debug & DEBUG_N)
      display_nfa(tables, &firstpos, stdout);

/* Now convert the NFA into a DFA */

   build_dfa(tables, &firstpos);
   intset_free(&firstpos);
}


bool init_scangen
(
   sdt_tables *tables
)
{
/* Determine the size of the NFA and allocate space for it */

   if ((NFASIZE = count_positions(tables->scanner) + 1) <= INT_MAX)
   {
/*    Allocate NFA and start with state 1 */

      dynalloc(&tables->nfapositions, sizeof(position), NFASIZE);
      memset(&NFAPOSITION(0), 0, NFASIZE * NFAELEMENT);
      NFACOUNT = 1;

/*    Initialize the DFA and start with state 1 */

      dynalloc(&tables->dfastates, sizeof(dfastate), INITIAL_DFA_SIZE);
      memset(&DFASTATE(0), 0, INITIAL_DFA_SIZE * DFAELEMENT);
      DFACOUNT         = 1;
      tables->dfacount = 0;
      return(true);
   }
   else
   {
      puts("Regular expression too complicated, no scanner generated");
      return(false);
   }
}


static void list_tokens
(
   sdt_tables *tables,
   treenode   *tree,
   int	       width1,
   int	       width2,
   bool	       ignore,
   FILE	      *fp
)
{
/* Display the scanner abstract syntax tree in readable format */

   treenode    *node;
   symbolentry *symbol;
   int	        prec;

   node = tree->node.entry[3];
   if (tree->node.type == '.' && node->node.count == LEAF && node->leaf.type == REFERENCE && node->leaf.value.symbol->type == TERMINAL)
   {
/*    Tree is the concatenation of a regular expression and the token definition */

      prec = (tree->node.count > BINARY) ? precedence('_') : 0;
      if (ignore && node->leaf.value.symbol->value.value.token > tables->termcount)
	 if (node->leaf.value.symbol->value.value.flags & EMPTY)
	 {
	    list_values(tables, symbol = node->leaf.value.symbol, width1, width2, tree, prec, fp);
	    fputs(";\n", fp);
	    while (symbol->alias)
	    {
	       list_values(tables, symbol->alias, -width1, width2, tree, prec, fp);
	       fputs(";\n", fp);
	       symbol = symbol->alias;
	    }
	 }
	 else
	 {
	    fprintf(fp, "%*s   %*s  ignore", width1, " ", width2 + 3, " ");
	    for (node = tree->node.entry[0]; node->node.next; node = node->node.next)
	       display_expression(tables, node, prec, true, fp);
	    fputs(";\n", fp);
	 }
      else
	 if (!ignore && node->leaf.value.symbol->value.value.token <= tables->termcount)
	 {
	    list_values(tables, symbol = node->leaf.value.symbol, width1, width2, tree, prec, fp);
	    fputs(";\n", fp);
	    while (symbol->alias)
	    {
	       list_values(tables, symbol->alias, -width1, width2, tree, prec, fp);
	       fputs(";\n", fp);
	       symbol = symbol->alias;
	    }
	 }
   }
   else

/*    Tree is an alternation of a list of tokens */

      for (node = tree->node.entry[0]; node; node = node->node.next)
	 list_tokens(tables, node, width1, width2, ignore, fp);
}


static void list_values
(
   sdt_tables  *tables,
   symbolentry *symbol,
   int		width1,
   int		width2,
   treenode    *tree,
   int		prec,
   FILE	       *fp
)
{
/* Display an abstract syntax tree token in readable format */

   int	     length;
   treenode *node;

   if (width1 > 0)
      fprintf(fp, "%*d.  ", width1, symbol->value.value.token);
   else
      fprintf(fp, "%*s   ", -width1, " ");
   length = strlen(symbol->symbol);
   fprintf(fp, (strchr(symbol->symbol, '"')) ? "'%s'" : "\"%s\"", symbol->symbol);
   if (length < width2)
      fprintf(fp, "%*s", width2 - length, " ");
   fputs(" =", fp);
   for (node = tree->node.entry[0]; node->node.next; node = node->node.next)
      display_expression(tables, node, prec, true, fp);
   fprintf(fp, ", precedence = %d, insert = %d, delete = %d", symbol->value.value.precedence, symbol->value.value.insert, symbol->value.value.delete);
	if (symbol->value.value.flags & NONE)
      fputs(", associativity=none", fp);
   else if (symbol->value.value.flags & LEFT)
      fputs(", associativity=left", fp);
   else if (symbol->value.value.flags & RIGHT)
      fputs(", associativity=right", fp);
   if (symbol->value.value.flags & CASE)
      fputs(", ignore case", fp);
   if (symbol->value.value.flags & INSTALL)
      fputs(", install", fp);
   if (symbol->value.value.flags & ALIAS)
      fputs(", alias", fp);
   if (symbol->value.value.flags & EMPTY)
      fputs(", epsilon", fp);
}


static int lookup_state
(
   sdt_tables *tables,
   intset     *set
)
{
/* Create a DFA state representing a set of NFA states */

   int size;
   int i;

/* Check if DFA state already exists */

   for (i = 1; i < DFACOUNT; i++)
      if (intset_equal(&DFASTATE(i).states, set))
	 return(i);

/* Increase size of DFA array if it is already full */

   size = DFASIZE;
   if (dyncheck(&tables->dfastates, DFASIZE * 2))
      memset(&DFASTATE(DFACOUNT), 0, size * DFAELEMENT);

/* Initialize the new DFA state */

   DFASTATE(DFACOUNT).index = DFACOUNT;
   intset_copy(&DFASTATE(DFACOUNT).states, set);
   intset_alloc(&DFASTATE(DFACOUNT).tokens, INITIAL_TOKENS_SIZE);

/* Check all the NFA states in the set for end of token and final values */

   for (i = 0; i < INTCOUNT(*set); i++)
   {

/*    To support the lookahead operator every state in the DFA may be	     */
/*    associated with a set of tokens for which the state represents the     */
/*    end of the string which matches that token, as well as a single token  */
/*    which this state recognizes.  Every time the scanner enters a state    */
/*    it records the current input position with every entry in the end of   */
/*    token set.  Every time the scanner enters a state which recognises a   */
/*    token the final token number is recorded.  When no further transitions */
/*    in the DFA are valid, the last final token number encountered tells    */
/*    us which token was recognized and the end of token position for that   */
/*    token tells us where the matching string ends			     */

      if (NFAPOSITION(INTSET(*set, i)).token)
	 intset_insert(&DFASTATE(DFACOUNT).tokens, NFAPOSITION(INTSET(*set, i)).token);

/*    If this state represents more than one final token number in the NFA */
/*    record the one with the smallest value.  This condition means that   */
/*    more than one regular expression matches the same string and using   */
/*    the smallest value corresponds to giving precedence to the token	   */
/*    which was defined first.						   */

      if (NFAPOSITION(INTSET(*set, i)).final)
	 if (DFASTATE(DFACOUNT).final == 0 || NFAPOSITION(INTSET(*set, i)).final < DFASTATE(DFACOUNT).final)
	 {
	    DFASTATE(DFACOUNT).final   = NFAPOSITION(INTSET(*set, i)).final;
	    DFASTATE(DFACOUNT).install = NFAPOSITION(INTSET(*set, i)).install;
	 }
   }
   return(DFACOUNT++);
}


static void minimize_dfa
(
   sdt_tables *tables
)
{
   intset *partition;
   int	   count;
   bool	   changed;
   intset  group;
   int	   split;
   int	   i, j, k;

/* Construct initial partitions: all non-accepting states, one for each  */
/* lookahead state for a token, and one for each final state for a token */

   if (partition = (intset *) malloc(DFACOUNT * sizeof(*partition)))
      for (i = 0; i < DFACOUNT; i++)
	 intset_alloc(&partition[i], INITIAL_GROUP_SIZE);
   else
      out_of_memory();

/* Add each DFA state to the partition with the same token and final values */

   for (count = 0, i = 1; i < DFACOUNT; i++)
      if (INTCOUNT(DFASTATE(i).tokens) || DFASTATE(i).final)
      {
	 for (j = 1; j <= count; j++)
	    if (intset_equal(&DFASTATE(INTSET(partition[j], 0)).tokens, &DFASTATE(i).tokens) && DFASTATE(INTSET(partition[j], 0)).final == DFASTATE(i).final)
	       break;
	 intset_insert(&partition[j], i);
	 DFASTATE(i).index = j;

/*	 Remember if we created a new group */

	 if (j > count)
	    count = j;
      }
      else
	 intset_insert(&partition[0], i);

/* Move the partition of non-token non-final states to the end of the list */

   if (INTCOUNT(partition[0]))
   {
      intset_free(&partition[++count]);
      partition[count] = partition[0];
      partition[0].element = 0;
      partition[0].count   = 0;
      partition[0].size    = 0;
      partition[0].array = NULL;

/*    Remap all the DFA states to the new group number */

      for (i = 0; i < INTCOUNT(partition[count]); i++)
	 DFASTATE(INTSET(partition[count], i)).index = count;
   }

/* Split groups until one pass produces no new groups */

   do
   {
      changed = false;

      for (i = count; i; i--)
	 if (INTCOUNT(partition[i]) > 1)
	 {
/*	    Initialize indices of new groups added by split and copy */
/*	    the first state into the new group that is being created */

/*	    Save and remove partition[i] from the list of groups */

	    group	 = partition[i];
	    partition[i] = partition[count];

/*	    Distribute the states in group to new groups at the end of the list */

	    intset_alloc(&partition[count], INITIAL_GROUP_SIZE);
	    intset_insert(&partition[count], INTSET(group, 0));
	    split = count;

/*	    split is the index of the first new group being created */
/*	    Create new groups at the end of the list as necessary   */

	    for (j = 1; j < INTCOUNT(group); j++)
	    {
/*	       Find a compatible new group or create a new one at the end of the list */

	       for (k = split; k <= count && !compatible(tables, &DFASTATE(INTSET(partition[k], 0)), &DFASTATE(INTSET(group, j))); k++)
		  ;
	       intset_insert(&partition[k], INTSET(group, j));
	       if (k > count)
		  count = k;
	    }
	    intset_free(&group);

/*	    If this resulted in more than one group, set the changed flag */

	    if (count > split)
	       changed = true;

/*	    Fix the group number for the partition we moved down into the list */

	    if (i != split)
	       for (j = 0; j < INTCOUNT(partition[i]); j++)
		  DFASTATE(INTSET(partition[i], j)).index = i;

/*	    And set the group number for all the newly created partitions */

	    while (split <= count)
	    {
	       for (j = 0; j < INTCOUNT(partition[split]); j++)
		  DFASTATE(INTSET(partition[split], j)).index = split;
	       split++;
	    }
	 }
   }
   while (changed);

/* Remap all transitions to the first state within the respective group */

   for (i = 1; i < DFACOUNT; i++)
      for (j = 0; j < DFASTATE(i).count; j++)
	 DFASTATE(i).action[j].state = INTSET(partition[DFASTATE(DFASTATE(i).action[j].state).index], 0);

/* Clear every duplicate state, count the real states, and renumber them to sequential state numbers */

   for (tables->dfacount = 0, i = j = 1; i < DFACOUNT; i++)
      if (i != INTSET(partition[DFASTATE(i).index], 0))
      {
	 intset_free(&DFASTATE(i).tokens);
	 DFASTATE(i).final   = 0;
	 DFASTATE(i).install = 0;
	 free(DFASTATE(i).action);
	 DFASTATE(i).count   = 0;
	 DFASTATE(i).index   = 0;
      }
      else
      {
	 DFASTATE(i).index   = j++;
	 tables->dfacount++;
      }

/* Free minimization partitions */

   for (i = 1; i < DFACOUNT; i++)
      intset_free(&partition[i]);
   free(partition);
}


void write_scanner
(
   sdt_tables *tables,
   FILE	      *fp
)
{
/* Create scanner output entries */

   int	count;
   int	limit;
   bool full;
   int	length;
   int	width1;
   int	width2;
   int *index;
   int *table;
   int	i, j, k;

/* Count the number of important DFA states and the index of the last one */

   for (count = limit = 0, i = 1; i < DFACOUNT; i++)
      if (DFASTATE(i).index)
      {
	 limit = i;
	 count++;
      }
   limit++;

/* Count the number of end of token values */

   for (j = 0, i = 1; i < limit; i++)
      j += INTCOUNT(DFASTATE(i).tokens);

/* Allocate space for the concatenated token values and their index */

   if ((index = (int *) malloc((count + 1) * sizeof(*index))) && (table = (int *) malloc(j * sizeof(index))))
   {
/*    Pack end of token values into table and initialize index */

      for (count = j = 0, i = 1; i < limit; i++)
	 if (DFASTATE(i).index)
	 {
	    index[j++] = count;
	    for (k = 0; k < INTCOUNT(DFASTATE(i).tokens); k++)
	       table[count++] = INTSET(DFASTATE(i).tokens, k);
	 }
      index[j++] = count;
   }
   else
      out_of_memory();

/* Write the end of token index table */

   for (width1 = 0, i = 0; i < j; i++)
      if (index[i] > width1)
	 width1 = index[i];
   width1 = digit_count(width1);

   for (full = false, length = 0, i = 0; i < j; i++)
   {
      if (length + width1 > MAXLINE || full)
      {
	 fputc('\n', fp);
	 full   = false;
	 length = 0;
      }
      fprintf(fp, "%*d", width1, index[i]); 
      length += width1;
      if (i < j - 1 && length + 1 + width1 <= MAXLINE)
      {
	 fputc(' ', fp);
	 length++;
      }
      else
	 full = true;
   }
   if (length)
      fputc('\n', fp);

/* Write the concatenated end of token values */

   for (width1 = 0, i = 0; i < count; i++)
      if (table[i] > width1)
	 width1 = table[i];
   width1 = digit_count(width1);

   for (full = false, length = 0, i = 0; i < count; i++)
   {
      if (length + width1 > MAXLINE || full)
      {
	 fputc('\n', fp);
	 full   = false;
	 length = 0;
      }
      fprintf(fp, "%*d", width1, table[i]); 
      length += width1;
      if (i < count - 1 && length + 1 + width1 <= MAXLINE)
      {
	 fputc(' ', fp);
	 length++;
      }
      else
	 full = true;
   }
   if (length)
      fputc('\n', fp);

   free(index);
   free(table);

/* Write final value table */

   for (width1 = 0, i = 1; i < limit; i++)
      if (DFASTATE(i).final > width1)
	 width1 = DFASTATE(i).final;
   width1 = digit_count(width1);

   for (full = false, length = 0, i = 1; i < limit; i++)
      if (DFASTATE(i).index)
      {
	 if (length + width1 > MAXLINE || full)
	 {
	    fputc('\n', fp);
	    full   = false;
	    length = 0;
	 }
	 fprintf(fp, "%*d", width1, DFASTATE(i).final);
	 length += width1;
	 if (i < limit - 1 && length + 1 + width1 <= MAXLINE)
	 {
	    fputc(' ', fp);
	    length++;
	 }
	 else
	    full = true;
      }
   if (length)
      fputc('\n', fp);

/* Write install flag table */

   for (full = false, length = 0, i = 1; i < limit; i++)
      if (DFASTATE(i).index)
      {
	 if (length + 1 > MAXLINE || full)
	 {
	    fputc('\n', fp);
	    full   = false;
	    length = 0;
	 }
	 fprintf(fp, "%d", DFASTATE(i).install);
	 length++;
	 if (i < limit - 1 && length + 1 + 1 <= MAXLINE)
	 {
	    fputc(' ', fp);
	    length++;
	 }
	 else
	    full = true;
      }
   if (length)
      fputc('\n', fp);

/* Determine maximum size of state transition values */

   for (width2 = width1 = 0, i = 1; i < DFACOUNT; i++)
      if (DFASTATE(i).index)
	 for (j = 0; j < DFASTATE(i).count; j++)
	 {
	    if (DFASTATE(i).action[j].index > width1)
	       width1 = DFASTATE(i).action[j].index;
	    if (DFASTATE(i).action[j].state > width2)
	       width2 = DFASTATE(i).action[j].state;
	 }
   width1 = digit_count(width1);
   width2 = digit_count(width2);

/* Write state transitions */

   for (i = 1; i < DFACOUNT; i++)
      if (DFASTATE(i).index)
      {
	 fprintf(fp, "%d\n", DFASTATE(i).count);
	 for (full = false, length = j = 0; j < DFASTATE(i).count; j++)
	 {
	    if (length + width1 + 1 + width2 > MAXLINE || full)
	    {
	       fputc('\n', fp);
	       full   = false;
	       length = 0;
	    }
	    fprintf(fp, "%*d %*d", width1, DFASTATE(i).action[j].index, width2, DFASTATE(DFASTATE(i).action[j].state).index);
	    length += width1 + 1 + width2;
	    if (j < DFASTATE(i).count - 1 && length + 1 + width1 + 1 + width2 <= MAXLINE)
	    {
	       fputc(' ', fp);
	       length++;
	    }
	    else
	       full = true;
	 }
	 if (length)
	    fputc('\n', fp);
      }

/*    We're finished with the DFA so we can free it */

   free_automaton(tables);
}
